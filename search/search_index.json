{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Scrimage is an immutable, functional, and performant JVM library for manipulation of images.</p> <p>The aim of this library is to provide a simple and concise way to do common image operations, such as resizing to fit  a required width and height, converting between formats, applying filters and so on.  It is not intended to provide functionality that might be required by a more \"serious\" image processing application - such as face recognition or movement tracking.</p> <p>A typical use case for this library would be creating thumbnails of images uploaded by users in a web app, or bounding a set of product images so that they all have the same dimensions, or optimizing PNG uploads by users to apply maximum compression, or applying a grayscale filter in a print application.</p> <p>Scrimage mostly builds on the functionality provided by java.awt.* along with selected other third party libraries, such as drewnoakes/metadata-extractor and haraldk/TwelveMonkeys.</p>"},{"location":"#creation-methods","title":"Creation methods","text":"<p>Creation methods create a new image by specifying the dimensions. They can start with a specified colour using fill or undefined using blank. An image can be created by copying an existing image.</p>"},{"location":"#input-output","title":"Input / Output","text":"<p>The heart of any image library is reading and writing in the various formats. Scrimage supports all the formats provided by javax.imageio along with extra formats in the modules <code>scrimage-formats-extra</code> and <code>scrimage-webp</code>.</p>"},{"location":"#image-operations","title":"Image Operations","text":"<p>These operations operate on an image, returning a copy of that image. For instance, fit will resize an image to fit into a specified set of bounds, and scale will change the size of an image.</p> <p>For the full list of operations, see the menu on the left.</p>"},{"location":"#filters","title":"Filters","text":"<p>Scrimage comes with a wide array of filters in the module <code>scrimage-filters</code>.</p>"},{"location":"#composites","title":"Composites","text":""},{"location":"#metadata","title":"Metadata","text":"<p>Scrimage builds on the metadata-extractor project to provide the ability to read metadata from an image.</p> <p>Read more details here.</p>"},{"location":"#quick-examples","title":"Quick Examples","text":"<p>Reading an image, scaling it to 50% using the Bicubic method, and writing out as PNG <pre><code>val in = ... // input stream\nval out = ... // output stream\nImmutableImage.loader().fromStream(in).scale(0.5, Bicubic).output(out) // an implicit PNG writer is in scope by default\n</code></pre></p> <p>Reading an image from a java File, applying a blur filter, then flipping it on the horizontal axis, then writing out as a Jpeg <pre><code>val inFile = ... // input File\nval outFile = ... // output File\nImmutableImage.loader().fromFile(inFile).filter(BlurFilter).flipX.output(outFile)(JpegWriter()) // specified Jpeg\n</code></pre></p> <p>Padding an image with a 20 pixel border around the edges in red <pre><code>val in = ... // input stream\nval out = ... // output stream\nImmutableImage.loader().fromStream(in).pad(20, Color.Red)\n</code></pre></p> <p>Enlarging the canvas of an image without scaling the image. Note: the resize methods change the canvas size, and the scale methods are used to scale/resize the actual image. This terminology is consistent with Photoshop. <pre><code>val in = ... // input stream\nval out = ... // output stream\nImmutableImage.loader().fromStream(in).resize(600,400)\n</code></pre></p> <p>Scaling an image to a specific size using a fast non-smoothed scale <pre><code>val in = ... // input stream\nval out = ... // output stream\nImmutableImage.loader().fromStream(in).scaleTo(300, 200, FastScale)\n</code></pre></p> <p>Writing out a heavily compressed Jpeg thumbnail <pre><code>implicit val writer = JpegWriter().withCompression(50)\nval in = ... // input stream\nval out = ... // output stream\nImmutableImage.loader().fromStream(in).fit(180,120).output(new File(\"image.jpeg\"))\n</code></pre></p> <p>Printing the sizes and ratio of the image <pre><code>val in = ... // input stream\nval out = ... // output stream\nval image = ImmutableImage.loader().fromStream(in)\nprintln(\"Width: ${image.width} Height: ${image.height} Ratio: ${image.ratio}\")\n</code></pre></p> <p>Converting a byte array in JPEG to a byte array in PNG <pre><code>val in : Array[Byte] = ... // array of bytes in JPEG say\nval out = Image(in).write // default is PNG\nval out2 = ImmutableImage.loader().fromBytes(in).bytes) // an implicit PNG writer is in scope by default with max compression\n</code></pre></p> <p>Coverting an input stream to a PNG with no compression <pre><code>implicit val writer = PngWriter.NoCompression\nval in : InputStream = ... // some input stream\nval out = ImmutableImage.loader().fromStream(in).stream\n</code></pre></p>"},{"location":"animated_gif/","title":"Animated GIFs","text":"<p>Scrimage supports reading and writing animated GIFs.</p>"},{"location":"animated_gif/#reading","title":"Reading","text":"<p>We read an instance of an <code>AnimatedGif</code> by using the <code>AnimatedGifReader.read</code> method, passing in an <code>ImageSource</code>. The image source can be constructed from files, bytes, input streams and so on.</p> <p>Once we have the animated gif object, we can inspect that to retrieve an <code>ImmutableImage</code> per frame, the total number of frames, delay per frame and so on.</p> Java <pre><code>AnimatedGif gif = AnimatedGifReader.read(ImageSource.of(...));\nImmutableImage firstFrame = gif.getFrame(0);\nImmutableImage lastFrame = gif.getFrame(gif.getFrameCount() - 1);\n</code></pre> Kotlin <pre><code>val gif = AnimatedGifReader.read(ImageSource.of(...))\nval firstFrame = gif.frames().first()\nval lastFrame = gif.frames().last()\n</code></pre> Scala <pre><code>val gif = AnimatedGifReader.read(ImageSource.of(...))\nval firstFrame = gif.frames.head\nval lastFrame = gif.frames.last\n</code></pre>"},{"location":"animated_gif/#writing","title":"Writing","text":"<p>Using the <code>StreamingGifWriter</code> class, first we create an instance of the writer, specifying the frame delay (delay between images) and if we should loop. Then we open a stream, specifying either an output path or an output stream, and the AWT image type we want the images to be created with.</p> Java <pre><code>StreamingGifWriter writer = new StreamingGifWriter(Duration.ofSeconds(2), true);\nGifStream gif = writer.prepareStream(\"/path/to/gif.gif\", BufferedImage.TYPE_INT_ARGB);\n</code></pre> Kotlin <pre><code>val writer = StreamingGifWriter(Duration.ofSeconds(2), true)\nval gif = writer.prepareStream(\"/path/to/gif.gif\", BufferedImage.TYPE_INT_ARGB)\n</code></pre> Scala <pre><code>val writer = new StreamingGifWriter(Duration.ofSeconds(2), true)\nval gif = writer.prepareStream(\"/path/to/gif.gif\", BufferedImage.TYPE_INT_ARGB)\n</code></pre> <p>Next we can add as many images as we want, each an instance of an <code>ImmutableImage</code>. Eg,</p> <pre><code>gif.writeFrame(image0);\ngif.writeFrame(image1);\ngif.writeFrame(imageN);\n</code></pre> <p>Finally, we close the stream by invoking finish, and the data is finalized to the output stream or path.</p> <pre><code>gif.finish();\n</code></pre> <p>Note</p> <p>Browsers have a minimum frame delay. If you try to set the frame delay lower than the minimum for that browser, the browser will use the default frame delay. The default frame delay is not equal to the minimum. Chrome and Firefox have a minimum frame delay of 0.2 seconds and IE and Safari 0.6 seconds.</p>"},{"location":"api_intro/","title":"Introduction","text":"<p>The core data type in Scrimage is the <code>ImmutableImage</code> class. This wraps a Java AWT image with functions that return copies of the image instead of mutating it.</p> <p>We can create such an instance specifying the dimensions, or we can load an image from one of the supported formats.</p> <p>Once we have an image in memory, we can perform an operation on it that returns a new image. Such as scale, resize, brightness, autocrop and so on.</p> <p>There are pixel functions available, ways to interact with different color namespaces, dozens of filters, or composites.</p> <p>If the underlying source supports it, we can interrogate the associated metadata.</p> <p>Finally, we can save the image back to a file, byte array or stream.</p>"},{"location":"autocrop/","title":"Autocrop","text":""},{"location":"autocrop/#autocrop","title":"Autocrop","text":"<p>Autocrop is a way of removing excess background on an image.</p> <p>Let's say you had an image that was surrounded by a lot of white background, and you wanted to remove that background so that all that remained was the main image, then autocrop is what you want.</p> <p>It works by checking the pixels of each row and column at the sides, top, and bottom, and working inwards. It removes those rows and columns if they consist entirely of the specified colour.</p> <p>To use, invoke <code>autocrop</code> on an image and pass in the colour to be used as the background detection color.</p> <p>For example to remove excess white background:</p> <pre><code>image.autocrop(Color.WHITE)\n</code></pre> <p>or to remove a background of a custom color you could do: <pre><code>image.autocrop(new RGBColor(255, 235, 10).awt())\n</code></pre></p>"},{"location":"autocrop/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>image.autocrop(new RGBColor(255, 107, 0).awt())\n</code></pre> <p></p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Some noddy benchmarks comparing the speed of rescaling an image. I've compared the basic getScaledInstance method in java.awt.Image with ImgScalr and Scrimage. ImgScalr delegates to awt.Graphics2D for its rendering. Scrimage adapts the methods implemented by Morten Nobel.</p> <p>The code is inside src/test/scala/com/sksamuel/scrimage/ScalingBenchmark.scala.</p> <p>The results are for 100 runs of a resize to a fixed width / height.</p> Library Fast High Quality (Method) java.awt.Image.getScaledInstance 11006ms 17134ms (Area Averaging) ImgScalr 57ms 5018ms (ImgScalr.Quality) Scrimage 113ms 2730ms (Bicubic) <p>As you can see, ImgScalr is the fastest for a simple rescale, but Scrimage is much faster than the rest for a high quality scale.</p>"},{"location":"blur-and-stretch/","title":"Blur and stretch","text":""},{"location":"blur-and-stretch/#blur-and-stretch","title":"Blur and stretch","text":"<p>See this issue</p> <p>Sometimes when you change canvas size of your image you want to use something more fancy than plain solid color as a background. One of possible solutions is to use blurred version of your image as a background. Basically this guide shows one possible way to achieve it using basic <code>Image</code> operations and blur filter (<code>LensBlurFilter</code> was chosen as an example).</p> <p>You just need to: 1. scale image to desired dimensions to make a foreground, e.g. using <code>scaleToRatio</code>. In code below this step is omitted for simplicity: <code>val fgImage = image</code> 2. scale image using cover and apply some blur via <code>filter</code> to make a background 3. complete process by putting foreground on top of background using <code>overlay</code></p> <pre><code>import java.nio.file.Paths\n\nimport com.sksamuel.scrimage.{Image, ScaleMethod}\nimport com.sksamuel.scrimage.filter.LensBlurFilter\n\nval image = Image.fromPath(Paths.get(\"examples\", \"images\", \"lanzarote_small.jpeg\"))\nval filter = new LensBlurFilter(12f, 2f, 255f, 10)\n// for simplicity of example source image is not scaled\nval fgImage = image\nval targetWidth = fgImage.width * 2\nval targetHeight = fgImage.height\nimage\n  .cover(targetWidth, targetHeight, ScaleMethod.FastScale)\n  .filter(filter)\n  .overlay(fgImage, x = (targetWidth - fgImage.width) / 2, y = (targetHeight - fgImage.height) / 2)\n</code></pre> <p>Compare original and result:</p>      Before       After"},{"location":"bound/","title":"Bound","text":"<p>Ensures that the image is no larger than specified dimensions.</p> <p>If the source image is larger, it will be scaled down, maintaining aspect ratio.</p> <p>If the source image is smaller, it will be returned unmodified.</p> <p>This is useful when you want to ensure images do not exceed a give size, but you don't want to scale up the image if is already smaller.</p>"},{"location":"bound/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.bound(400, 300)</code> <code>image.bound(500, 200)</code> <code>image.bound(300, 500)</code>"},{"location":"brightness/","title":"Brightness","text":"<p>Returns a new Image with the brightness adjusted by the given factor.</p>"},{"location":"brightness/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> Code Output <code>image.brightness(2.0)</code> <code>image.brightness(0.5)</code>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#435-sept-2025","title":"4.3.5 (Sept 2025)","text":"<ul> <li>Use java.nio to make file executable by @torstenkuhnhenne in #317</li> </ul>"},{"location":"changelog/#433-july-2025","title":"4.3.3 (July 2025)","text":"<ul> <li>Add ImageLoader.fromUrl</li> </ul>"},{"location":"changelog/#432-june-2025","title":"4.3.2 (June 2025)","text":"<ul> <li>Optimize single-color fill methods (#304)</li> </ul>"},{"location":"changelog/#431-april-2025","title":"4.3.1 (April 2025)","text":"<ul> <li>Added DominantGradient transform</li> </ul>"},{"location":"changelog/#430-december-2024","title":"4.3.0 (December 2024)","text":"<ul> <li>Updated to use webp 1.4.0</li> </ul>"},{"location":"changelog/#420-august-2024","title":"4.2.0 (August 2024)","text":"<ul> <li>Removed open-gif library which is no longer maintained. #292</li> </ul>"},{"location":"changelog/#413-april-2024","title":"4.1.3 (April 2024)","text":"<ul> <li>Fixed for multithread builder method (#290)</li> </ul>"},{"location":"changelog/#412-april-2024","title":"4.1.2 (April 2024)","text":"<ul> <li>Added the option to use multithreading when encoding webp (#287)</li> <li>Support webp in linux os with aarch64 architecture (#286)</li> </ul>"},{"location":"changelog/#411","title":"4.1.1","text":"<ul> <li>Fixed RGB colour average calcuation #280</li> </ul>"},{"location":"changelog/#410","title":"4.1.0","text":"<ul> <li>Default webp on macos to use ARM architecture#278</li> <li>Fixed filters that require int data type #277</li> </ul>"},{"location":"changelog/#4041","title":"4.0.41","text":"<ul> <li>Fixed withInfiniteLoop(false) on gif writers. #272</li> </ul>"},{"location":"changelog/#4040","title":"4.0.40","text":"<ul> <li>Added the system property <code>com.sksamuel.scrimage.webp.platform=mac-arm64</code> to specify to use webp-mac-arm64 binaries. #276</li> </ul>"},{"location":"changelog/#4039","title":"4.0.39","text":"<ul> <li>Added the system property \"com.sksamuel.scrimage.webp.binary.dir\" to configure the directory of the webp binaries. (#274)</li> </ul>"},{"location":"changelog/#4038","title":"4.0.38","text":"<ul> <li>Added the option to generate the webp file without alpha. (#270)</li> </ul>"},{"location":"changelog/#4037","title":"4.0.37","text":"<ul> <li>Better error message when image loading fails, to indicate the file type.</li> </ul>"},{"location":"changelog/#4036","title":"4.0.36","text":"<ul> <li>Fixed webp support for windows that was broken in 4.0.34</li> </ul>"},{"location":"changelog/#4035","title":"4.0.35","text":"<ul> <li>Fixed bug stopping PNG compression from being applied to some types of images.</li> </ul>"},{"location":"changelog/#4034","title":"4.0.34","text":"<ul> <li>Updated webp to 1.3.0</li> <li>Removed deprecated use of finalizer</li> </ul>"},{"location":"changelog/#4033","title":"4.0.33","text":"<ul> <li>Add withCompression option to StreamingGifWriter #256</li> <li>Fixed JpegWriter.NoCompression preset is misleading #255</li> </ul>"},{"location":"changelog/#4032","title":"4.0.32","text":"<ul> <li>Add convert animated gif to animated webp (#253)</li> </ul>"},{"location":"changelog/#4031","title":"4.0.31","text":"<ul> <li>Add dispose method support when writing frames with StreamingGifWriter #242 zalmb8</li> <li>Handle temp files when compressing webp (#246)</li> <li>Bumped twelve monkeys library to 3.8.2</li> <li>Added methods to copy a pixel by changing one component.</li> <li>Added method to clone an AWT image with another image type.</li> </ul>"},{"location":"changelog/#4030","title":"4.0.30","text":"<ul> <li>Updated error message on the ImageIOReader.</li> <li>Removed noisy println</li> </ul>"},{"location":"changelog/#4029","title":"4.0.29","text":"<ul> <li>Added extra constructor for ImageIOReader that accepts javax readers</li> </ul>"},{"location":"changelog/#4028","title":"4.0.28","text":"<ul> <li>Added <code>withImageReaders</code> to ImmutableImageLoader to allow specifying the <code>ImageReader</code> implements to use.</li> </ul>"},{"location":"changelog/#4027","title":"4.0.27","text":"<ul> <li>Added process destroy to explicitly remove resources in the webp module.</li> </ul>"},{"location":"changelog/#4026","title":"4.0.26","text":"<ul> <li>Clean up /tmp files when decompressing using the webp module. #240 Jeff Bilicki</li> </ul>"},{"location":"changelog/#4025","title":"4.0.25","text":"<ul> <li>Updated <code>FormatDetector</code> to detect webp (#238) Ilia</li> </ul>"},{"location":"changelog/#4024","title":"4.0.24","text":"<ul> <li>Updated <code>StreamingGifWriter</code> to support writing to any <code>OutputStream</code> in addition to the existing file/path options.</li> </ul>"},{"location":"changelog/#4023","title":"4.0.23","text":"<ul> <li>Fixed issue with autocrop when no changes are required.</li> </ul>"},{"location":"changelog/#4022","title":"4.0.22","text":"<ul> <li>Bumped 12monkeys and commons-io versions.</li> </ul>"},{"location":"changelog/#4021","title":"4.0.21","text":"<ul> <li>Added <code>AnimatedGifReader.read(inputstream)</code>, to allow reading each frame of an animated GIF as an <code>ImmutableImage</code>.</li> </ul>"},{"location":"changelog/#4020","title":"4.0.20","text":"<ul> <li>Autocrop now works on fully transparent pixels.</li> </ul>"},{"location":"changelog/#4019","title":"4.0.19","text":"<ul> <li>All dependencies no longer transitively include kotlin-stdlib.</li> <li>Support webp binary in multiple o/s.</li> </ul>"},{"location":"changelog/#4018","title":"4.0.18","text":"<ul> <li>Core dependency no longer transitively includes kotlin-stdlib.</li> </ul>"},{"location":"changelog/#4017","title":"4.0.17","text":"<ul> <li>Added <code>withClassloader</code> option to <code>ImmutableImageLoader</code> to support discovery of <code>ImageReader</code> instances on arbitrary   classpaths.</li> </ul>"},{"location":"changelog/#4016","title":"4.0.16","text":"<ul> <li>Fixed webp support on Windows</li> </ul>"},{"location":"changelog/#4015","title":"4.0.15","text":"<ul> <li>Fixed regression in <code>ScaleMethod.Bicubic</code> scale speed.</li> <li>Added <code>ScaleMethod.Progressive</code> scaling method.</li> </ul>"},{"location":"colors/","title":"Colors","text":"<p>Most functions in Scrimage that deal with colours, accept an instance of java.awt.Color, however this class is limited. Scrimage provides its own <code>com.sksamuel.scrimage.color.Color</code> interface with implementations in the following color spaces:</p> <ul> <li>RGB</li> <li>CMYK</li> <li>Grayscale</li> <li>HSL</li> <li>HSV</li> </ul> <p>Each of these implementations can be converted to the other. For example:</p> <pre><code>new RGBColor(255, 0, 255).toHSV();\n</code></pre> <p>or</p> <pre><code>new HSLColor(100f, 0.5f, 0.3f, 1f).toRGB();\n</code></pre> <p>When you want to create a colour to pass to a scrimage function, you can convert the Scrimage color type to an AWT color type via the <code>toAwt()</code> method.</p> <p>You can retrieve the <code>average()</code> color value from  <code>color</code>.</p>"},{"location":"colors/#x11-colors","title":"X11 Colors","text":"<p>There is a full list of X11 defined colors in the <code>X11Colorlist</code> class. These can be used and converted to an AWT <code>Color</code> when you need more than the defaults built into the JDK.</p> <p>For example, to copy an image, setting all pixels to misty rose, we can use the following code:</p> <p><code>image.fill(X11Colorlist.MistyRose.awt())</code></p>"},{"location":"composites/","title":"Composites","text":"<p>Scrimage comes with several composites. A composite merges two images with each pixel composited together using the rule provided by the composite class.</p> <p>This grid shows the effect of compositing a palm tree image over a US mailbox image. The first column is the composite with a value of 0.5f, and the second column with 1f. Note, if you reverse the order of the images then the effects would be reversed.</p> <p>The code required to perform a composite is simple:</p> Java <pre><code>ImmutableImage composed = image1.composite(new XYZComposite(alpha), image2)\n</code></pre> Kotlin <pre><code>val composed = image1.composite(XYZComposite(alpha), image2)\n</code></pre> Scala <pre><code>val composed = image1.composite(new XYZComposite(alpha), image2)\n</code></pre> <p>Click on an example to see it full screen.</p> Composite Alpha 0.5f Alpha 1f average blue color colorburn colordodge diff green grow hue hard heat lighten negation luminosity multiply negation normal overlay red reflect saturation screen subtract"},{"location":"contrast/","title":"Contrast","text":"<p>Returns a new image with the contrast adjusted by the given factor.</p>"},{"location":"contrast/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>image.contrast(2.0)\n</code></pre> <p></p> <pre><code>image.contrast(0.5)\n</code></pre> <p></p>"},{"location":"cover/","title":"Cover","text":"<p>The cover operation creates an image with the specified dimensions, with the original image scaled to cover the whole canvas, such that there is no added \"background\".</p> <p>If the source and target dimensions do not have the same aspect ratio then part of the source image will be lost as it will have to be \"over scaled\" to completely cover the target image.</p> <p>This is similar to taking a 16:9 movie and resizing it for a 4:3 screen. You can either lose part of the image (this operation) or resize it so there is empty space on two sides (the fit operation).</p> <p>Compare this operation with fit.</p> <p>To use, invoke with the target dimensions and optionally, a scale method (defaults to ScaleMethod.Bicubic), and the position of the source  image in the target (defaults to Position.Center).</p> <p>That last parameter has no effect if the aspect ratios are the same,  since the image will cover the target without any loss.</p>"},{"location":"cover/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> <pre><code>image.cover(400, 300)\n</code></pre> <p></p> <pre><code>image.cover(500, 200)\n</code></pre> <p></p> <pre><code>image.cover(500, 200, Position.TopLeft)\n</code></pre> <p></p> <pre><code>image.cover(400, 400)\n</code></pre> <p></p> <pre><code>image.cover(400, 400, Position.CenterRight)\n</code></pre> <p></p>"},{"location":"create/","title":"Create","text":"<p>There are a couple of ways to create a completely empty image.</p> <p>The first is with the <code>create</code> static method on <code>ImmutableImage</code>. This allows us to specify the width, height and optionally the AWT image type (eg 4 byte ARGB).</p> <p>For example,</p> <pre><code>// defaults to TYPE_INT_ARGB\nImmutableImage.create(400, 300)\n\n// specifying the image type\nImmutableImage.create(400, 300, BufferedImage.TYPE_4BYTE_ABGR)\n</code></pre> <p>Another way to create an image, is to call <code>blank</code> on an existing image. This will return a new image with the same type and size and an uninitialized raster.</p> <pre><code>image.blank()\n</code></pre> <p>Finally, <code>copy</code> allows us to copy an existing image, with each pixel copied. This function allows us to specify the type of the copy as well.</p> <pre><code>// copy with the data duplicated\nimage.copy()\n\n// copy with the data duplicated, and the raster using the specified type\nImmutableImage.copy(BufferedImage.TYPE_4BYTE_ABGR)\n</code></pre>"},{"location":"extra_formats/","title":"Formats-Extra","text":"<p>Scrimage provides for support for many common formats outside the standard Java ImageIO classes via an optional module.</p> <p>The <code>scrimage-formats-extra</code> module brings in additional formats such as PCX, BMP, TGA and more. It also includes a better TIFF reader than the one available in the standard java library and a customizable TIFF writer.</p> <p>To read from these formats, just add the module to your classpath, nothing more.</p> <p>To write using these formats, pass an instance of the applicable <code>ImageWriter</code> interface when saving out the format.</p> <p>For example,</p> <pre><code>image.output(new BmpWriter(), new File(\"output.bmp\"))\n</code></pre> <p>or</p> <pre><code>image.output(new PcxWriter(), new File(\"output.pcx\"))\n</code></pre>"},{"location":"faq/","title":"Faq","text":""},{"location":"faq/#faq","title":"FAQ","text":"<ul> <li>I know the format of the files I want to load, can I optimize the parsing process?</li> </ul> <p>By constraining the ImageReaders to a specific format(s), the image parsers don't need to work out what format your file is in. You can use something like the following as an example for a JPEG only loader.</p> <pre><code>val reader = ImageIO.getImageReadersByFormatName(\"JPEG\").asSequence().first()\nval jpegLoader = ImmutableImageLoader.create().withImageReaders(listOf(ImageIOReader(listOf(reader))))\n</code></pre> <ul> <li>I have added <code>scrimage-webp</code> but I still can't load WebP images when I create a far jar.</li> </ul> <p>Scrimage, like many other libraries, uses the <code>ServiceLoader</code> mechanism to load image readers and writers. This mechanism is based on the <code>META-INF/services</code> directory in the JAR file. When you create a fat jar, you must ensure that all <code>META-INF/services</code> directories are merged, otherwise the <code>ServiceLoader</code> mechanism will not work as expected.</p> <p>For instance, if you are using the gradle shadow plugin, you can read instructions here. If you are using SBT assembly, instructions are here. Other fat jar plugins should have similar instructions.</p>"},{"location":"fill/","title":"Fill","text":"<p>Creates a new image with the same dimensions as a source image, setting each pixel to the specified colour.</p> <p>In addition to the colour, the function accepts a Painter which can be used to apply a gradient.</p>"},{"location":"fill/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>// a new image with all pixels blue, and the dimensions\n// taken from the source image\nimage.fill(Color.BLUE)\n</code></pre> <p></p> <pre><code>// a new image with the pixels coloured from the given vertical gradient.\nimage.fill(LinearGradient.vertical(Color.BLACK, Color.WHITE))\n</code></pre> <p></p> <pre><code>// a new image with the pixels coloured from the given horizontal gradient\nimage.fill(LinearGradient.horizontal(Color.BLACK, Color.WHITE))\n</code></pre> <p></p>"},{"location":"filters/","title":"Filters","text":"<p>Scrimage comes with a wide array of filters. A filter modifies the pixels of an image in some pre-determined way. For example, a simple filter might reduce the brightness of each pixel by 50%.</p> <p>Most of these filters I have not written myself, but rather collected from other open source imaging libraries (for compliance with licenses and / or attribution - see file headers), and either wrapped them, fixed bugs or improved them.</p> <p>!!! note These filters require the <code>scrimage-filters</code> module to be added to your build.</p> <p>Applying a filter returns a new image. The original image is unmodified. Some filters have options which can be set when creating the filters. All filters are immutable. Most filters have sensible default options as default parameters.</p> <p>To apply a filter, we just use the <code>filter</code> method on an image, for example:</p> Java <pre><code>ImmutableImage filtered = image.filter(new DitherFilter())\n</code></pre> Kotlin <pre><code>val filtered = image.filter(DitherFilter())\n</code></pre> Scala <pre><code>val filtered = image.composite(new DitherFilter())\n</code></pre> <p>Click on the small images to see an enlarged example.</p> Filter Example 1 Example 2 Example 3 black_threshold blur border brightness bump caption chrome color_halftone colorize contour contrast crystallize despeckle diffuse dither edge emboss error_diffusion_halftone gain_bias gamma gaussian glow gotham grayscale hsb invert_alpha invert kaleidoscope lensblur lensflare minimum maximum motionblur nashville noise offset oil old_photo opacity pixelate pointillize_square posterize prewitt quantize rays rgb ripple roberts rylanders sepia sharpen smear_circles snow sobels solarize sparkle summer swim television threshold tritone twirl unsharp vignette vintage watermark_cover watermark_stamp"},{"location":"fit/","title":"Fit","text":"<p>The fit operation creates an image with the specified dimensions, with the original image scaled to fit exactly inside, as large as possible, without losing any of the original image.</p> <p>If the source and target dimensions do not have the same aspect ratio then the original image will not cover the entire output image, so the excess background is set to a default color.</p> <p>The difference between this and max, is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will result an equal amount of scaling, but fit will pad the canvas with a background color so that it precisely matches the input dimensions.</p> <p>The difference between this and cover is that cover will also return an image with the specified dimensions, but will size the image to ensure there is no background padding required, but potentially losing some of the source image.</p> <p>To use, invoke with the target dimenions and optionally, a background color (defaults to Color.WHITE), a scale method (defaults to ScaleMethod.Bicubic), and the position of the source image in the target (defaults to Position.Center).</p> <p>That last parameter has no effect if the aspect ratios are the same (because in that case the image would fit exactly inside anyway).</p>"},{"location":"fit/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.fit(400, 300, Color.DARK_GRAY)</code> <code>image.fit(300, 300, Color.BLUE)</code> <code>image.fit(400, 100, Color.RED)</code>"},{"location":"flip/","title":"Flip","text":"<p>Flips the image either horizontally or vertically.</p>"},{"location":"flip/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.flipX()</code> <code>image.flipY()</code>"},{"location":"format_detection/","title":"Format Detection","text":"<p>If you are interested in detecting the format of an image (which you don't need to do when simply loading an image,  as Scrimage will figure it out for you) then you can use the <code>FormatDetector</code>.</p> <p>The detector recognises PNG, JPEG and GIF.</p> <p>This method does not need to load all bytes, only the initial few bytes to determine what the format is.</p> <p>The return value is an Optional with the detected format, or a None if unable to detect. <pre><code>// detect from a byte array\nFormatDetector.detect(bytes)\n\n// detect from an input stream\nFormatDetector.detect(inputStream)\n</code></pre>"},{"location":"io/","title":"Reading / Writing","text":"<p>Scrimage supports loading and saving of images in the common web formats (png, jpeg, gif, tiff, webp). In addition, it extends javas image.io support by giving you an easy way to set options on the output format when saving.</p> <p>Warning</p> <p>The TIFF support via javax.imageio has issues with some tiff images. If this happens, try using the <code>scrimage-formats-extra</code> module which provides extra TIFF support via the TwelveMonkeys library.</p>"},{"location":"io/#reading","title":"Reading","text":"<p>To load an image we use the <code>ImmutableImageLoader</code> interface. An instance can be created via <code>ImmutableImage.loader()</code>.</p> <p>This allows us to customize loading behavior and specify the input source. Supported sources are input streams, byte arrays, files, paths, classpath resources or anything that implements the <code>ImageSource</code> interface.</p> <p>For example, to load an image from the filesystem:</p> Java <pre><code>ImmutableImage image = ImmutableImage.loader().fromFile(file);\n</code></pre> Kotlin <pre><code>val image = ImmutableImage.loader().fromFile(file)\n</code></pre> Scala <pre><code>val image = ImmutableImage.loader().fromFile(file)\n</code></pre> <p>or to load from a byte array:</p> Java <pre><code>ImmutableImage image = ImmutableImage.loader().fromBytes(bytes);\n</code></pre> Kotlin <pre><code>val image = ImmutableImage.loader().fromBytes(bytes)\n</code></pre> Scala <pre><code>val image = ImmutableImage.loader().fromBytes(bytes)\n</code></pre> <p>We can load from byte arrays, streams, files, paths, resources and so on.</p>"},{"location":"io/#image-loader-options","title":"Image loader options","text":"<p>The <code>ImmutableImageLoader</code> has several options to customize loading.</p> Option Description detectOrientation If set to true (the default) then if the image has metadata that indeeds its orientation, then scrimage will rotate the image back to landscape detectMetadata If set to true (the default) then scrimage will attempt to parse the metadata tags (if any) present in the file type Sets the BufferedImage type that the loaded image should use. If unspecified then the default of the reader implementation is used sourceRegion Sets an area to load from the image. If you are loading an image to immediately crop, then this operation can result in less bytes being read from the source"},{"location":"io/#writing","title":"Writing","text":"<p>To save a method, Scrimage requires an <code>ImageWriter</code> for the format you wish to persist to. Scrimage does not use the file extension as a way to infer the format.</p> <p>Then you can use <code>output</code> or <code>bytes</code> to either write to a file or a byte array respectively.</p> <p>For example, to save an image as a PNG to a file:</p> Java <pre><code>ImmutableImage image = ... // some image\n// write out to a file\nimage.output(PngWriter.Default, new File(\"/home/sam/spaghetti.png\"));\n</code></pre> Kotlin <pre><code>val image = ... // some image\n// write out to a file\nimage.output(PngWriter.Default, File(\"/home/sam/spaghetti.png\"))\n</code></pre> Scala <pre><code>val image = ... // some image\n// write out to a file\nimage.output(PngWriter.Default, new File(\"/home/sam/spaghetti.png\"))\n</code></pre> <p>If you want to override the configuration for a writer then you can do this when you create the writer. For example to save a JPEG with 50% compression:</p> Java <pre><code>JpegWriter writer = new JpegWriter().withCompression(50).withProgressive(true);\nimage.output(writer, new File(\"/home/sam/spaghetti.png\"));\n</code></pre> Kotlin <pre><code>val writer = JpegWriter().withCompression(50).withProgressive(true)\nimage.output(writer, File(\"/home/sam/spaghetti.png\"))\n</code></pre> Scala <pre><code>val writer = new JpegWriter().withCompression(50).withProgressive(true)\nimage.output(writer, new File(\"/home/sam/spaghetti.png\"))\n</code></pre> <p>If you want to override the configuration for a writer then you can do this when you create the writer. For example to save a JPEG with 50% compression as a byte array:</p> Java <pre><code>JpegWriter writer = new JpegWriter().withCompression(50).withProgressive(true);\nimage.bytes(writer);\n</code></pre> Kotlin <pre><code>val writer = JpegWriter().withCompression(50).withProgressive(true)\nimage.bytes(writer)\n</code></pre> Scala <pre><code>val writer = new JpegWriter().withCompression(50).withProgressive(true)\nimage.bytes(writer)\n</code></pre>"},{"location":"io/#supported-writers","title":"Supported Writers","text":"<p>The available writers along with supported options are:</p> Writer Option Description <code>JpegWriter</code> compression Set a value between 0 (full lossy compression) and 100 (full quality / no compression) progressive If true then data is compressed in multiple passes of progressively higher detail <code>PngWriter</code> compression Set to a value between 0 (no compression) and 9 (max compression). Compression in PNG is lossless <code>GifWriter</code> progressive If true then data is compressed in multiple passes of progressively higher detail"},{"location":"max/","title":"Max","text":"<p>Scales an image to be as large as possible to fit into the specified dimensions whilst maintaining aspect ratio. This operation will not pad the image to ensure it matches the dimensions exactly.</p> <p>For example, starting with an image that is 300x200 and invoking <code>max(420,300)</code> will result in an image that is 420x280, because that is as large as the image can be without exceeding the required dimensions.</p> <p>Similarly, starting with 600x400 and invoking <code>max(400,100)</code> will result in an image that is 150x100.</p> <p>The difference between max and fit, is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will scale the image equally, but fit will pad the canvas with a background color so that it precisely matches the input dimensions.</p>"},{"location":"max/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.max(400, 300)</code> <code>image.max(300, 300)</code> <code>image.max(200, 400)</code>"},{"location":"metadata/","title":"Metadata","text":"<p>Scrimage builds on the metadata-extractor project to provide the ability to read metadata.</p> <p>This can be done in two ways. Firstly, the metadata is attached to the image if it was available when you loaded the image from the a stream, file or resource. Then you can call <code>image.metadata</code> to get a handle to the metadata object.</p> <p>Secondly, the metadata can be loaded without needing to create an image instance, by using the methods on <code>ImageMetadata</code>.</p> <p>Once you have the metadata object, you can invoke <code>directories</code> or <code>tags</code> to see the information.</p> <p>For example, we can print out all the tags in an image via this code:</p> Java <pre><code>ImageMetadata meta = ImageMetadata.fromStream(stream);\nArrays.stream(meta.tags()).forEach(tag -&gt; System.out.println(tag));\n</code></pre> Kotlin <pre><code>val meta = ImageMetadata.fromStream(stream)\nmeta.tags().forEach {\n  println(it)\n}\n</code></pre> Scala <pre><code>val meta = ImageMetadata.fromStream(stream)\nmeta.tags().asScala.foreach { tag =&gt;\n  println(tag)\n}\n</code></pre> <p>And the output will look something like:</p> <pre><code>...\nTag{name='Compression Type', type=-3, rawValue='0', value='Baseline'}\nTag{name='Data Precision', type=0, rawValue='8', value='8 bits'}\nTag{name='Image Height', type=1, rawValue='405', value='405 pixels'}\nTag{name='Image Width', type=3, rawValue='594', value='594 pixels'}\nTag{name='Resolution Units', type=7, rawValue='1', value='inch'}\nTag{name='X Resolution', type=8, rawValue='300', value='300 dots'}\nTag{name='Y Resolution', type=10, rawValue='300', value='300 dots'}\nTag{name='Thumbnail Width Pixels', type=12, rawValue='0', value='0'}\nTag{name='Thumbnail Height Pixels', type=13, rawValue='0', value='0'}\nTag{name='Image Width', type=256, rawValue='4928', value='4928 pixels'}\nTag{name='Image Height', type=257, rawValue='3280', value='3280 pixels'}\nTag{name='Bits Per Sample', type=258, rawValue='8 8 8', value='8 8 8 bits/component/pixel'}\nTag{name='Photometric Interpretation', type=262, rawValue='2', value='RGB'}\nTag{name='Image Description', type=270, rawValue='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.', value='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.'}\nTag{name='Make', type=271, rawValue='NIKON CORPORATION', value='NIKON CORPORATION'}\nTag{name='Model', type=272, rawValue='NIKON D4S', value='NIKON D4S'}\nTag{name='Orientation', type=274, rawValue='1', value='Top, left side (Horizontal / normal)'}\nTag{name='Samples Per Pixel', type=277, rawValue='3', value='3 samples/pixel'}\nTag{name='X Resolution', type=282, rawValue='72', value='72 dots per inch'}\nTag{name='Y Resolution', type=283, rawValue='72', value='72 dots per inch'}\n...\n</code></pre>"},{"location":"metadata/#orientation","title":"Orientation","text":"<p>The orientation tag is a commonly used tag, so there is a function to specifically retrieve this, if defined (sometimes, eg on Sony cameras, it is defined more than once!).</p> <p>These helper methods are found in the <code>OrientationTools</code> class.</p> <p>For example:</p> <pre><code>OrientationTools.imageOrientationsOf(image.metadata);\n</code></pre>"},{"location":"orientation/","title":"Orientation","text":"<p>Apple iPhone's have this annoying \"feature\" where an image taken when the phone is rotated is not saved as a rotated file. Instead the image is always saved as landscape with a flag set to whether it was portrait or not. Scrimage will detect this flag, if it is present on the file, and correct the orientation for you automatically. Most image readers do this, such as web browsers, but you might have noticed some things do not, such as intellij.</p> <p>Note: This can be disabled by setting <code>detectOrientation(false)</code> on the <code>ImmutableImage.loader()</code> instance.</p>"},{"location":"overlay/","title":"Overlay","text":"<p>Returns a new image which is the original image plus a specified image overlaid on top.</p> <p>The overlaying image is placed at an offset starting at 0,0 at the top left.</p> <p>A negative offset will start the image \"off canvas\".</p> <p>Any excess pixels from the overlay image are ignored. For example, if the overlay image is too large, or overlaps.</p>"},{"location":"overlay/#examples","title":"Examples","text":"<p>Using these images as our input:</p> <p></p> <p></p> <pre><code>image.overlay(picard, 25, 25)\n</code></pre> <p></p> <pre><code>image.overlay(picard, -75, 0)\n</code></pre> <p></p>"},{"location":"pad/","title":"Pad","text":"<p>Resizes the canvas by adding a number of pixels around the edges in a given color. This is the opposite of the trim operation.</p> <p>Pad can add pixels uniformly around all edges using <code>pad(k)</code> or on a specified edge only, using <code>padLeft(k)</code> and so on.</p>"},{"location":"pad/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>image.scale(0.5)\n     .pad(10, Color.DARK_GRAY)\n</code></pre> <p></p> <pre><code>image.scale(0.5)\n     .padRight(25, Color.BLUE)\n     .padBottom(40, Color.RED)\n</code></pre> <p></p>"},{"location":"pixels/","title":"Pixel Functions","text":"<p>There are several functions available on <code>ImmutableImage</code> that operate at the pixel level.</p> <p>To return all pixels in an image, we can use <code>image.argb()</code> or <code>image.pixels()</code>. The former returns pixels as ARGB integer encodings, and the latter returns them as <code>Pixel</code> objects.</p> <p><code>image.pixel(x,y)</code> returns the pixel at the given coordinates and <code>count()</code> returns the total number of pixels in the image.</p> <p>If we want to count the number of pixels that satisfy a predicate, we can use the version of count that accepts a function.</p> <pre><code>// count number of pixels with some blue\nimage.count(pixel -&gt; pixel.blue() &gt; 0)\n</code></pre> <p>If you wish to run a side-effecting function for every pixel, then use <code>forEach</code>.</p> <pre><code>image.forEach(pixel -&gt; {\n  if (pixel.blue() == 255) {\n    System.out.println(\"Is totally blue man!\");\n  }\n});\n</code></pre> <p>If you want to return a new image, mapping each pixel to another colour, then use <code>map</code>.</p> <pre><code>// remove all blue\nimage.map(pixel -&gt; new RGBColor(pixel.red(), pixel.green(), 0).awt());\n</code></pre> <p>If you wish to check an image to see if at least one pixel satisfies a predicate, then use <code>exists</code>.</p> <pre><code>// returns true if any pixel has some blue\nimage.exists(pixel -&gt; pixel.blue() &gt; 0);\n</code></pre> <p>If you wish to run a predicate against every pixel, and return true if all pixels satisfy that predicate, then use <code>forAll</code>.</p> <pre><code>// returns true if all pixels have some blue\nimage.forAll(pixel -&gt; pixel.blue() &gt; 0);\n</code></pre>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#including-scrimage-in-your-project","title":"Including Scrimage in your project","text":"<p>Scrimage is available on maven central. There are several modules.</p> <p>One is the <code>scrimage-core</code> library which is required. The others are <code>scrimage-filters</code>, <code>scrimage-formats-extra</code>, <code>scrimage-webp</code>. And if you're using Scala you can also add <code>scrimage-scala_2.12</code> or <code>scrimage-scala_2.13</code> for enhanced scala functions.</p> <p>They are split into several modules because the image filters is a large jar, and most people just want the basic resize/scale/load/save functionality.</p> <p>The<code>scrimage-formats-extra</code> package brings in readers/writers for less common formats such as BMP, Tiff or PCX. These formats are wrappers around the TwelveMonkeys library.</p> Gradle <pre><code>implementation(\"com.sksamuel.scrimage:scrimage-core:&lt;version&gt;\")\n</code></pre> SBT <pre><code>libraryDependencies += \"com.sksamuel.scrimage\" % \"scrimage-core\" % \"$version\"\nlibraryDependencies += \"com.sksamuel.scrimage\" %% \"scrimage-scala\" % \"$version\"\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.sksamuel.scrimage&lt;/groupId&gt;\n    &lt;artifactId&gt;scrimage-core&lt;/artifactId&gt;\n    &lt;version&gt;${version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"quick_start/#scala-helpers","title":"Scala Helpers","text":"<p>If you are using Scala and you have added the scala module, then add the import <code>import com.sksamuel.scrimage.implicits._</code> to bring into scope some useful implicits.</p> <p>Firstly, an implicit <code>PNGWriter</code> so you do not have to specify it when outputting images. Secondly, a conversion to / from <code>java.awt.Color</code> and Scrimage's <code>RGBColor</code>. Lastly, forall, foreach and map methods on <code>ImmutableImage</code> which work with Scala functions.</p>"},{"location":"resize/","title":"Resize","text":"<p>Resizes the canvas to the given dimensions.</p> <p>This does not scale the image but simply changes the dimensions of the canvas on which the image is sitting.</p> <p>Specifying a larger size will pad the image with a background color and specifying a smaller size will crop the image. This is the operation most people want when they think of crop.</p> <p>We can specify a position which will be used to anchor the source image in the new canvas.</p> <p>When resizing, we can specify a factor to multiply the current dimensions by, such as <code>image.resize(0.5)</code>, or we can specify target sizes specifically, such as <code>image.resizeTo(400,300)</code>, or we can resize the width or height independently.</p>"},{"location":"resize/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>image.resize(0.75)\n</code></pre> <p></p> <pre><code>// with added colour to show the padded canvas\nimage.resizeTo(400, 400, Color.MAGENTA)\n</code></pre> <p></p> <pre><code>// anchoring the source to the bottom right corner\nimage.resizeTo(400, 300, Position.BottomRight)\n</code></pre> <p></p> <pre><code>// resizing only one dimension\nimage.resizeToWidth(400)\n</code></pre> <p></p>"},{"location":"rotate/","title":"Rotate","text":"<p>Rotates the image clockwise or anti-clockwise.</p>"},{"location":"rotate/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.rotateLeft()</code> <code>image.rotateRight()</code> <code>image.rotate(new Radians(1.15))</code>"},{"location":"scale/","title":"Scale","text":"<p>Scales an image up or down. This operation will change both the canvas and the image. This is what most people want when they think of \"resizing\" an image.</p> <p>If instead, we wish to change the image \"canvas\" without scaling up or down, then resize is the right operation.</p> <p>We can perform a scale operation with a specified width and height. Or we can specify only a width or height and Scrimage will adjust the other dimension to keep the aspect ratio constant.</p> <p>Alternatively, we can specify a scale factor, which will multiply the width and height by that factor.</p>"},{"location":"scale/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>image.scaleToWidth(400) // keeps aspect ratio\n</code></pre> <p></p> <pre><code>image.scaleToHeight(200) // keeps aspect ratio\n</code></pre> <p></p> <pre><code>image.scaleTo(400, 400)\n</code></pre> <p></p> <pre><code>// using the fast scale method\nimage.scaleTo(400, 400, ScaleMethod.FastScale)\n</code></pre> <p></p> <pre><code>image.scale(0.5) // keeps aspect ratio, applies factor to width and height\n</code></pre> <p></p>"},{"location":"scale/#scale-algorithms","title":"Scale Algorithms","text":"<p>Each scale operation has a <code>ScaleMethod</code> parameter that allows us to specify the algorithm to be used when performing the scale. Options are <code>FastScale</code>, <code>Lanczos3</code>, <code>BSpline</code>, <code>Bilinear</code>, <code>Bicubic</code>. Bicucbic is the default.</p> <p>Here is the same image scaled using each of the algorithms. Click on the image to see the full size.</p> <p>Fast Scale</p> <p></p> <p>BSpline</p> <p></p> <p>Lanczos3</p> <p></p> <p>Bilinear</p> <p></p> <p>Bicubic</p> <p></p>"},{"location":"take/","title":"Take","text":"<p>Returns a new Image which is the source image, but only keeping a specified number of pixels from the top, bottom, left or right.</p> <p>For example, <code>takeLeft(k)</code> will return a subimage with bounds <code>[0, 0, k, height]</code>.</p>"},{"location":"take/#examples","title":"Examples","text":"<p>Using this image scaled to 640 x 360 as our input:</p> <p></p> Code Output <code>image.takeLeft(300)</code> <code>image.takeLeft(300).takeTop(200)</code> <code>image.takeRight(400).takeBottom(200)</code>"},{"location":"transforms/","title":"Transforms","text":"<p>A transform modifies an image and returns a new image derived from that input. A transform is similar to a filter, but where a filter modifies the pixels of an image, a transform can return an entirely new image.</p> <p>Click on an example to see it full screen.</p>"},{"location":"transforms/#background-gradient","title":"Background Gradient","text":"<p>Produces a linear gradient background underlay for the two most dominent colours of an image.</p> Java <pre><code>ImmutableImage transformed = image1.transform(new BackgroundGradient(400, 300))\n</code></pre> Kotlin <pre><code>val transformed = image1.transform(BackgroundGradient(400, 300))\n</code></pre> Scala <pre><code>val transformed = image1.transform(new BackgroundGradient(400, 300))\n</code></pre> Input Output"},{"location":"transforms/#dominant-gradient","title":"Dominant Gradient","text":"<p>Produces a linear gradient copy of the image for the two most dominent colours of an image.</p> Java <pre><code>ImmutableImage transformed = image1.transform(new DominantGradient())\n</code></pre> Kotlin <pre><code>val transformed = image1.transform(DominantGradient())\n</code></pre> Scala <pre><code>val transformed = image1.transform(new DominantGradient())\n</code></pre> Input Output"},{"location":"translate/","title":"Translate","text":"<p>Returns a new image with the original image translated (moved) the specified number of pixels. We can translate on either axis and in either direction. Additionally, a background colour can be specified.</p>"},{"location":"translate/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code> // translate 100 pixels right\nimage.translate(100, 0)\n</code></pre> <p></p> <pre><code> // translate 100 pixels right with specified bg\nimage.translate(100, 0, Color.BLUE)\n</code></pre> <p></p> <pre><code> // translate on both axis\nimage.translate(120, 80)\n</code></pre> <p></p> <pre><code> // translate in negative directions with specified bg\nimage.translate(120, -80, Color.RED)\n</code></pre> <p></p>"},{"location":"trim/","title":"Trim","text":""},{"location":"trim/#trim","title":"Trim","text":"<p>The trim operation shrinks the canvas size on a specified or all sides. You can think of it as removing a border.</p> <p>To remove the same amount of pixels on all side, invoke with a single parameter.</p> <p><pre><code>image.trim(15)\n</code></pre> or to specify each side seperately</p> <pre><code>image.trim(5, 40, 5, 19)\n</code></pre>"},{"location":"trim/#examples","title":"Examples","text":"<p>Using this image as our starting input:</p> <p></p> <pre><code>image.trim(50) // will remove 50 pixels on all sides\n</code></pre> <p></p> <pre><code> image.trimLeft(100) // remove 100 pixels from the left side\n</code></pre> <p></p> <pre><code>image.trimBottom(200) // will remove 200 pixels from the bottom\n</code></pre> <p></p>"},{"location":"webp/","title":"Webp","text":""},{"location":"webp/#webp-support","title":"Webp Support","text":"<p>Webp is a method of lossy and lossless compression created by Google.</p> <p>Scrimage provides support for webp through the <code>scrimage-webp</code> module. To use webp, add this module to your build.</p> <p>Note: Read the faq with regards to using this module inside a fat jar.</p> <p>This module uses the <code>dwebp</code>, <code>cwebp</code> and <code>gif2webp</code> binaries, created by Google. The <code>scrimage-webp</code> module comes with the linux_x64, linux_aarch64, window_x64, mac-x64 and mac-arm64 binaries already included (see required copyright notice).</p> <p>If you don't wish to use the embedded binaries, then you can download other versions and use the system property \"com.sksamuel.scrimage.webp.binary.dir\" to configure the directory you placed the binaries: <pre><code>java -Dcom.sksamuel.scrimage.webp.binary.dir=\"/tmp/webp\" -jar myprogram.jar\n</code></pre> Or you can place them on your classpath at <code>/webp_binaries/{osName}/dwebp</code> or <code>/webp_binaries/{osName}/cwebp</code> or <code>/webp_binaries/{osName}/gif2webp</code>. The directory set by the system property is always searched first.</p> <p><code>{osName}</code> must be one of <code>window</code>, <code>linux</code>, <code>mac</code>. ie <code>/webp_binaries/window/cwebp</code>.</p> <p>or just place your binaries into <code>/webp_binaries/dwebp</code> or <code>/webp_binaries/cwebp</code> or <code>/webp_binaries/gif2webp</code>. then scrimage will use <code>/webp_binaries/{binary}</code> regardless of the binaries which is in os specific directory.</p> <p>Then you should be able to read webp files by using the <code>ImageLoader</code> as normal:</p> <pre><code>ImmutableImage.loader().fromFile(new File(\"someimage.webp\"))\n</code></pre> <p>And write out images using the WebpWriter image writer, eg.</p> <pre><code>myimage.output(WebpWriter.MAX_LOSSLESS_COMPRESSION,\"output.webp\");\n</code></pre>"},{"location":"webp/#animated-gif-to-webp","title":"Animated Gif to Webp","text":"<p>The writer is configuration with options for compression quality, compression method, and lossless compression factor.</p> <p>If want to change Animated Gif to webp, you should be able to read animated file by using by <code>AnimatedGifReader</code> as normal :</p> <pre><code>AnimatedGifReader.read(ImageSource.of(File(\"animated.gif\"));\n</code></pre> <p>And write out AnimatedGif using the Gif2WebpWriter, eg.</p> <pre><code>animatedGif.bytes(Gif2WebpWriter.DEFAULT);\n\nanimatedGif.output(Gif2WebpWriter.DEFAULT, \"output.webp\");\n</code></pre> <p>The gif2webp writer is configuration with options for compression quality, compression method, and lossly compression factor.</p> <p>animated webp to animated gif is not currently supported in this module.</p>"},{"location":"zoom/","title":"Zoom","text":"<p>Returns a new image that is the result of scaling this image, but without changing the canvas size.</p> <p>This can be thought of as similar to zooming in on a camera. When you zoom on a camera, the size of the viewpane does not increase, and some parts of the image are no longer visible.</p> <p>The <code>zoom</code> operation accepts a scale factor to apply to the dimensions, and optionally a scale method. If the scale method is not specified, then BICUBIC is used.</p>"},{"location":"zoom/#examples","title":"Examples","text":"<p>Using this image as our input:</p> <p></p> <pre><code>// zoom with default scale method\nimage.zoom(1.3)\n</code></pre> <p></p> <pre><code>// zoom with a specified scale method.\nimage.scaleToHeight(200, Scalemethod.FastScale)\n</code></pre> <p></p>"}]}